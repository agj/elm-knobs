module KeepOpenTests exposing (..)

import Expect exposing (Expectation)
import Internal.Constants
import Knob exposing (Knob)
import Test
import Test.Html.Event as Event
import Test.Html.Selector as Selector
import Util.TestKnob exposing (Vegetable(..), afterEvent, knobSelect, simulateEvent, simulateEvents, viewHas, viewHasNot)


initialStateTests =
    Test.describe "Lets the panel close by default"
        [ Test.test "float" <|
            \() ->
                Knob.float { step = 0.1, initial = 1 }
                    |> viewIsNotKeptOpen
        , Test.test "floatConstrained" <|
            \() ->
                Knob.floatConstrained { range = ( -9999, 9999 ), step = 0.1, initial = 1 }
                    |> viewIsNotKeptOpen
        , Test.test "floatSlider" <|
            \() ->
                Knob.floatSlider { range = ( -9999, 9999 ), step = 0.1, initial = 1 }
                    |> viewIsNotKeptOpen
        , Test.test "int" <|
            \() ->
                Knob.int { step = 1, initial = 1 }
                    |> viewIsNotKeptOpen
        , Test.test "intConstrained" <|
            \() ->
                Knob.intConstrained { step = 1, range = ( -1000, 1000 ), initial = 1 }
                    |> viewIsNotKeptOpen
        , Test.test "intSlider" <|
            \() ->
                Knob.intSlider { step = 1, range = ( -1000, 1000 ), initial = 1 }
                    |> viewIsNotKeptOpen
        , Test.test "stringInput" <|
            \() ->
                Knob.stringInput "x"
                    |> viewIsNotKeptOpen
        , Test.test "stringTextarea" <|
            \() ->
                Knob.stringTextarea { columns = Nothing, rows = Nothing, initial = "x" }
                    |> viewIsNotKeptOpen
        , Test.test "boolCheckbox" <|
            \() ->
                Knob.boolCheckbox False
                    |> viewIsNotKeptOpen
        , Test.test "select" <|
            \() ->
                knobSelect Carrot Carrot
                    |> .knob
                    |> viewIsNotKeptOpen
        , Test.test "colorPicker" <|
            \() ->
                Knob.colorPicker { red = 1, green = 1, blue = 1 }
                    |> viewIsNotKeptOpen
        , Test.test "compose" <|
            \() ->
                Knob.compose (\a b c -> ( a, b, c ))
                    |> Knob.stack (Knob.int { step = 1, initial = 1 })
                    |> Knob.stack (knobSelect Carrot Carrot |> .knob)
                    |> Knob.stack (Knob.float { step = 1, initial = 1 })
                    |> viewIsNotKeptOpen
        , Test.test "compose with label" <|
            \() ->
                Knob.compose (\a b c -> ( a, b, c ))
                    |> Knob.stackLabel "int" (Knob.int { step = 1, initial = 1 })
                    |> Knob.stackLabel "select" (knobSelect Carrot Carrot |> .knob)
                    |> Knob.stackLabel "float" (Knob.float { step = 1, initial = 1 })
                    |> viewIsNotKeptOpen
        , Test.test "map" <|
            \() ->
                let
                    { knob, toString } =
                        knobSelect Carrot Carrot
                in
                knob
                    |> Knob.map (\val -> toString val ++ "!")
                    |> viewIsNotKeptOpen
        ]


onFocusTests =
    Test.describe "Keeps the panel open on focus"
        [ Test.test "select" <|
            \() ->
                knobSelect Carrot Carrot
                    |> .knob
                    |> simulateEvent "select" Event.focus
                    |> afterEvent viewIsKeptOpen
        , Test.test "colorPicker" <|
            \() ->
                Knob.colorPicker { red = 1, green = 1, blue = 1 }
                    |> simulateEvent "input" Event.focus
                    |> afterEvent viewIsKeptOpen
        , Test.test "compose" <|
            \() ->
                Knob.compose (\a b c -> ( a, b, c ))
                    |> Knob.stack (Knob.int { step = 1, initial = 1 })
                    |> Knob.stack (knobSelect Carrot Carrot |> .knob)
                    |> Knob.stack (Knob.float { step = 1, initial = 1 })
                    |> simulateEvent "select" Event.focus
                    |> afterEvent viewIsKeptOpen
        , Test.test "compose with label" <|
            \() ->
                Knob.compose (\a b c -> ( a, b, c ))
                    |> Knob.stackLabel "int" (Knob.int { step = 1, initial = 1 })
                    |> Knob.stackLabel "select" (knobSelect Carrot Carrot |> .knob)
                    |> Knob.stackLabel "float" (Knob.float { step = 1, initial = 1 })
                    |> simulateEvent "select" Event.focus
                    |> afterEvent viewIsKeptOpen
        , Test.test "map" <|
            \() ->
                let
                    { knob, toString } =
                        knobSelect Carrot Carrot
                in
                knob
                    |> Knob.map (\val -> toString val ++ "!")
                    |> simulateEvent "select" Event.focus
                    |> afterEvent viewIsKeptOpen
        ]


onBlurTests =
    Test.describe "Lets the panel close on blur"
        [ Test.test "select" <|
            \() ->
                knobSelect Carrot Carrot
                    |> .knob
                    |> simulateEvents "select" Event.focus [ Event.blur ]
                    |> afterEvent viewIsNotKeptOpen
        , Test.test "colorPicker" <|
            \() ->
                Knob.colorPicker { red = 1, green = 1, blue = 1 }
                    |> simulateEvents "input" Event.focus [ Event.blur ]
                    |> afterEvent viewIsNotKeptOpen
        , Test.test "compose" <|
            \() ->
                Knob.compose (\a b c -> ( a, b, c ))
                    |> Knob.stack (Knob.int { step = 1, initial = 1 })
                    |> Knob.stack (knobSelect Carrot Carrot |> .knob)
                    |> Knob.stack (Knob.float { step = 1, initial = 1 })
                    |> simulateEvents "select" Event.focus [ Event.blur ]
                    |> afterEvent viewIsNotKeptOpen
        , Test.test "compose with label" <|
            \() ->
                Knob.compose (\a b c -> ( a, b, c ))
                    |> Knob.stackLabel "int" (Knob.int { step = 1, initial = 1 })
                    |> Knob.stackLabel "select" (knobSelect Carrot Carrot |> .knob)
                    |> Knob.stackLabel "float" (Knob.float { step = 1, initial = 1 })
                    |> simulateEvents "select" Event.focus [ Event.blur ]
                    |> afterEvent viewIsNotKeptOpen
        , Test.test "map" <|
            \() ->
                let
                    { knob, toString } =
                        knobSelect Carrot Carrot
                in
                knob
                    |> Knob.map (\val -> toString val ++ "!")
                    |> simulateEvents "select" Event.focus [ Event.blur ]
                    |> afterEvent viewIsNotKeptOpen
        ]


serializationTests =
    Test.describe "Does not keep the panel open after deserialization"
        [ Test.test "select" <|
            \() ->
                knobSelect Carrot Carrot
                    |> .knob
                    |> simulateEvent "select" Event.focus
                    |> afterEvent
                        (\knob ->
                            Knob.readSerialized (Knob.serialize knob) knob
                                |> viewIsNotKeptOpen
                        )
        , Test.test "colorPicker" <|
            \() ->
                Knob.colorPicker { red = 1, green = 1, blue = 1 }
                    |> simulateEvent "input" Event.focus
                    |> afterEvent
                        (\knob ->
                            Knob.readSerialized (Knob.serialize knob) knob
                                |> viewIsNotKeptOpen
                        )
        ]



-- UTILITIES


viewIsKeptOpen : Knob a -> Expectation
viewIsKeptOpen =
    viewHas [ Selector.class Internal.Constants.keepOpenCssClass ]


viewIsNotKeptOpen : Knob a -> Expectation
viewIsNotKeptOpen =
    viewHasNot [ Selector.class Internal.Constants.keepOpenCssClass ]
